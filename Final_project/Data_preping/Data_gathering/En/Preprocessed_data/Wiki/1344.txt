a central processing unit cpu also called a central processor main processor or just processor is the electronic circuitry that executes instructions comprising a computer program
the cpu performs basic arithmetic logic controlling and input output i o operations specified by the instructions in the program
this contrasts with external components such as main memory and i o circuitry and specialized processors such as graphics processing units gpus
the form design and implementation of cpus have changed over time but their fundamental operation remains almost unchanged
principal components of a cpu include the arithmetic logic unit alu that performs arithmetic and logic operations processor registers that supply operands to the alu and store the results of alu operations and a control unit that orchestrates the fetching from memory decoding and execution of instructions by directing the coordinated operations of the alu registers and other components
most modern cpus are implemented on integrated circuit ic microprocessors with one or more cpus on a single ic chip
microprocessor chips with multiple cpus are multi core processors
the individual physical cpus processor cores can also be multithreaded to create additional virtual or logical cpus
an ic that contains a cpu may also contain memory peripheral interfaces and other components of a computer such integrated devices are variously called microcontrollers or systems on a chip soc
array processors or vector processors have multiple processors that operate in parallel with no unit considered central
virtual cpus are an abstraction of dynamical aggregated computational resources
early computers such as the eniac had to be physically rewired to perform different tasks which caused these machines to be called fixed program computers
the central processing unit term has been in use since as early as
since the term cpu is generally defined as a device for software computer program execution the earliest devices that could rightly be called cpus came with the advent of the stored program computer
the idea of a stored program computer had been already present in the design of j
presper eckert and john william mauchly s eniac but was initially omitted so that it could be finished sooner
on june before eniac was made mathematician john von neumann distributed the paper entitled first draft of a report on the edvac
it was the outline of a stored program computer that would eventually be completed in august
edvac was designed to perform a certain number of instructions or operations of various types
significantly the programs written for edvac were to be stored in high speed computer memory rather than specified by the physical wiring of the computer
this overcame a severe limitation of eniac which was the considerable time and effort required to reconfigure the computer to perform a new task
with von neumann s design the program that edvac ran could be changed simply by changing the contents of the memory
edvac however was not the first stored program computer the manchester baby a small scale experimental stored program computer ran its first program on june and the manchester mark ran its first program during the night of june
early cpus were custom designs used as part of a larger and sometimes distinctive computer
however this method of designing custom cpus for a particular application has largely given way to the development of multi purpose processors produced in large quantities
this standardization began in the era of discrete transistor mainframes and minicomputers and has rapidly accelerated with the popularization of the integrated circuit ic
the ic has allowed increasingly complex cpus to be designed and manufactured to tolerances on the order of nanometers
both the miniaturization and standardization of cpus have increased the presence of digital devices in modern life far beyond the limited application of dedicated computing machines
modern microprocessors appear in electronic devices ranging from automobiles to cellphones and sometimes even in toys
while von neumann is most often credited with the design of the stored program computer because of his design of edvac and the design became known as the von neumann architecture others before him such as konrad zuse had suggested and implemented similar ideas
the so called harvard architecture of the harvard mark i which was completed before edvac also used a stored program design using punched paper tape rather than electronic memory
the key difference between the von neumann and harvard architectures is that the latter separates the storage and treatment of cpu instructions and data while the former uses the same memory space for both
most modern cpus are primarily von neumann in design but cpus with the harvard architecture are seen as well especially in embedded applications for instance the atmel avr microcontrollers are harvard architecture processors
relays and vacuum tubes thermionic tubes were commonly used as switching elements a useful computer requires thousands or tens of thousands of switching devices
the overall speed of a system is dependent on the speed of the switches
vacuum tube computers such as edvac tended to average eight hours between failures whereas relay computers like the slower but earlier harvard mark i failed very rarely
in the end tube based cpus became dominant because the significant speed advantages afforded generally outweighed the reliability problems
most of these early synchronous cpus ran at low clock rates compared to modern microelectronic designs
clock signal frequencies ranging from khz to mhz were very common at this time limited largely by the speed of the switching devices they were built with
the design complexity of cpus increased as various technologies facilitated building smaller and more reliable electronic devices
the first such improvement came with the advent of the transistor
transistorized cpus during the s and s no longer had to be built out of bulky unreliable and fragile switching elements like vacuum tubes and relays
with this improvement more complex and reliable cpus were built onto one or several printed circuit boards containing discrete individual components
in ibm introduced its ibm system computer architecture that was used in a series of computers capable of running the same programs with different speed and performance
this was significant at a time when most electronic computers were incompatible with one another even those made by the same manufacturer
to facilitate this improvement ibm used the concept of a microprogram often called microcode which still sees widespread usage in modern cpus
the system architecture was so popular that it dominated the mainframe computer market for decades and left a legacy that is still continued by similar modern computers like the ibm zseries
in digital equipment corporation dec introduced another influential computer aimed at the scientific and research markets the pdp
transistor based computers had several distinct advantages over their predecessors
aside from facilitating increased reliability and lower power consumption transistors also allowed cpus to operate at much higher speeds because of the short switching time of a transistor in comparison to a tube or relay
the increased reliability and dramatically increased speed of the switching elements which were almost exclusively transistors by this time cpu clock rates in the tens of megahertz were easily obtained during this period
additionally while discrete transistor and ic cpus were in heavy usage new high performance designs like single instruction multiple data simd vector processors began to appear
these early experimental designs later gave rise to the era of specialized supercomputers like those made by cray inc and fujitsu ltd
during this period a method of manufacturing many interconnected transistors in a compact space was developed
the integrated circuit ic allowed a large number of transistors to be manufactured on a single semiconductor based die or chip
at first only very basic non specialized digital circuits such as nor gates were miniaturized into ics
cpus based on these building block ics are generally referred to as small scale integration ssi devices
ssi ics such as the ones used in the apollo guidance computer usually contained up to a few dozen transistors
to build an entire cpu out of ssi ics required thousands of individual chips but still consumed much less space and power than earlier discrete transistor designs
ibm s system follow on to the system used ssi ics rather than solid logic technology discrete transistor modules
dec s pdp i and ki pdp also switched from the individual transistors used by the pdp and pdp to ssi ics and their extremely popular pdp line was originally built with ssi ics but was eventually implemented with lsi components once these became practical
lee boysel published influential articles including a manifesto which described how to build the equivalent of a bit mainframe computer from a relatively small number of large scale integration circuits lsi
the only way to build lsi chips which are chips with a hundred or more gates was to build them using a metal oxide semiconductor mos semiconductor manufacturing process either pmos logic nmos logic or cmos logic
however some companies continued to build processors out of bipolar transistor transistor logic ttl chips because bipolar junction transistors were faster than mos chips up until the s a few companies such as datapoint continued to build processors out of ttl chips until the early s
in the s mos ics were slower and initially considered useful only in applications that required low power
following the development of silicon gate mos technology by federico faggin at fairchild semiconductor in mos ics largely replaced bipolar ttl as the standard chip technology in the early s
as the microelectronic technology advanced an increasing number of transistors were placed on ics decreasing the number of individual ics needed for a complete cpu
msi and lsi ics increased transistor counts to hundreds and then thousands
by the number of ics required to build a complete cpu had been reduced to ics of eight different types with each ic containing roughly mosfets
in stark contrast with its ssi and msi predecessors the first lsi implementation of the pdp contained a cpu composed of only four lsi integrated circuits
since the introduction of the first commercially available microprocessor the intel in and the first widely used microprocessor the intel in this class of cpus has almost completely overtaken all other central processing unit implementation methods
mainframe and minicomputer manufacturers of the time launched proprietary ic development programs to upgrade their older computer architectures and eventually produced instruction set compatible microprocessors that were backward compatible with their older hardware and software
combined with the advent and eventual success of the ubiquitous personal computer the term cpu is now applied almost exclusively to microprocessors
several cpus denoted cores can be combined in a single processing chip
previous generations of cpus were implemented as discrete components and numerous small integrated circuits ics on one or more circuit boards
microprocessors on the other hand are cpus manufactured on a very small number of ics usually just one
the overall smaller cpu size as a result of being implemented on a single die means faster switching time because of physical factors like decreased gate parasitic capacitance
this has allowed synchronous microprocessors to have clock rates ranging from tens of megahertz to several gigahertz
additionally the ability to construct exceedingly small transistors on an ic has increased the complexity and number of transistors in a single cpu many fold
this widely observed trend is described by moore s law which had proven to be a fairly accurate predictor of the growth of cpu and other ic complexity until
while the complexity size construction and general form of cpus have changed enormously since the basic design and function has not changed much at all
almost all common cpus today can be very accurately described as von neumann stored program machines
as moore s law no longer holds concerns have arisen about the limits of integrated circuit transistor technology
extreme miniaturization of electronic gates is causing the effects of phenomena like electromigration and subthreshold leakage to become much more significant
these newer concerns are among the many factors causing researchers to investigate new methods of computing such as the quantum computer as well as to expand the usage of parallelism and other methods that extend the usefulness of the classical von neumann model
the fundamental operation of most cpus regardless of the physical form they take is to execute a sequence of stored instructions that is called a program
the instructions to be executed are kept in some kind of computer memory
nearly all cpus follow the fetch decode and execute steps in their operation which are collectively known as the instruction cycle
after the execution of an instruction the entire process repeats with the next instruction cycle normally fetching the next in sequence instruction because of the incremented value in the program counter
if a jump instruction was executed the program counter will be modified to contain the address of the instruction that was jumped to and program execution continues normally
in more complex cpus multiple instructions can be fetched decoded and executed simultaneously
this section describes what is generally referred to as the classic risc pipeline which is quite common among the simple cpus used in many electronic devices often called microcontrollers
it largely ignores the important role of cpu cache and therefore the access stage of the pipeline
some instructions manipulate the program counter rather than producing result data directly such instructions are generally called jumps and facilitate program behavior like loops conditional program execution through the use of a conditional jump and existence of functions
in some processors some other instructions change the state of bits in a flags register
these flags can be used to influence how a program behaves since they often indicate the outcome of various operations
for example in such processors a compare instruction evaluates two values and sets or clears bits in the flags register to indicate which one is greater or whether they are equal one of these flags could then be used by a later jump instruction to determine program flow
the first step fetch involves retrieving an instruction which is represented by a number or sequence of numbers from program memory
the instruction s location address in program memory is determined by the program counter pc called the instruction pointer in intel x microprocessors which stores a number that identifies the address of the next instruction to be fetched
after an instruction is fetched the pc is incremented by the length of the instruction so that it will contain the address of the next instruction in the sequence
often the instruction to be fetched must be retrieved from relatively slow memory causing the cpu to stall while waiting for the instruction to be returned
this issue is largely addressed in modern processors by caches and pipeline architectures see below
the instruction that the cpu fetches from memory determines what the cpu will do
in the decode step performed by binary decoder circuitry known as the instruction decoder the instruction is converted into signals that control other parts of the cpu
the way in which the instruction is interpreted is defined by the cpu s instruction set architecture isa
often one group of bits that is a field within the instruction called the opcode indicates which operation is to be performed while the remaining fields usually provide supplemental information required for the operation such as the operands
those operands may be specified as a constant value called an immediate value or as the location of a value that may be a processor register or a memory address as determined by some addressing mode
in some cpu designs the instruction decoder is implemented as a hardwired unchangeable binary decoder circuit
in others a microprogram is used to translate instructions into sets of cpu configuration signals that are applied sequentially over multiple clock pulses
in some cases the memory that stores the microprogram is rewritable making it possible to change the way in which the cpu decodes instructions
after the fetch and decode steps the execute step is performed
depending on the cpu architecture this may consist of a single action or a sequence of actions
during each action control signals electrically enable or disable various parts of the cpu so they can perform all or part of the desired operation
the action is then completed typically in response to a clock pulse
very often the results are written to an internal cpu register for quick access by subsequent instructions
in other cases results may be written to slower but less expensive and higher capacity main memory
for example if an addition instruction is to be executed registers containing operands numbers to be summed are activated as are the parts of the arithmetic logic unit alu that perform addition
when the clock pulse occurs the operands flow from the source registers into the alu and the sum appears at its output
on subsequent clock pulses other components are enabled and disabled to move the output the sum of the operation to storage e g a register or memory
if the resulting sum is too large i e it is larger than the alu s output word size an arithmetic overflow flag will be set influencing the next operation
hardwired into a cpu s circuitry is a set of basic operations it can perform called an instruction set
such operations may involve for example adding or subtracting two numbers comparing two numbers or jumping to a different part of a program
each instruction is represented by a unique combination of bits known as the machine language opcode
while processing an instruction the cpu decodes the opcode via a binary decoder into control signals which orchestrate the behavior of the cpu
a complete machine language instruction consists of an opcode and in many cases additional bits that specify arguments for the operation for example the numbers to be summed in the case of an addition operation
going up the complexity scale a machine language program is a collection of machine language instructions that the cpu executes
the actual mathematical operation for each instruction is performed by a combinational logic circuit within the cpu s processor known as the arithmetic logic unit or alu
in general a cpu executes an instruction by fetching it from memory using its alu to perform an operation and then storing the result to memory
beside the instructions for integer mathematics and logic operations various other machine instructions exist such as those for loading data from memory and storing it back branching operations and mathematical operations on floating point numbers performed by the cpu s floating point unit fpu
the control unit cu is a component of the cpu that directs the operation of the processor
it tells the computer s memory arithmetic and logic unit and input and output devices how to respond to the instructions that have been sent to the processor
it directs the operation of the other units by providing timing and control signals
most computer resources are managed by the cu
it directs the flow of data between the cpu and the other devices
john von neumann included the control unit as part of the von neumann architecture
in modern computer designs the control unit is typically an internal part of the cpu with its overall role and operation unchanged since its introduction
the arithmetic logic unit alu is a digital circuit within the processor that performs integer arithmetic and bitwise logic operations
the inputs to the alu are the data words to be operated on called operands status information from previous operations and a code from the control unit indicating which operation to perform
depending on the instruction being executed the operands may come from internal cpu registers or external memory or they may be constants generated by the alu itself
when all input signals have settled and propagated through the alu circuitry the result of the performed operation appears at the alu s outputs
the result consists of both a data word which may be stored in a register or memory and status information that is typically stored in a special internal cpu register reserved for this purpose
address generation unit agu sometimes also called address computation unit acu is an execution unit inside the cpu that calculates addresses used by the cpu to access main memory
by having address calculations handled by separate circuitry that operates in parallel with the rest of the cpu the number of cpu cycles required for executing various machine instructions can be reduced bringing performance improvements
while performing various operations cpus need to calculate memory addresses required for fetching data from the memory for example in memory positions of array elements must be calculated before the cpu can fetch the data from actual memory locations
those address generation calculations involve different integer arithmetic operations such as addition subtraction modulo operations or bit shifts
often calculating a memory address involves more than one general purpose machine instruction which do not necessarily decode and execute quickly
by incorporating an agu into a cpu design together with introducing specialized instructions that use the agu various address generation calculations can be offloaded from the rest of the cpu and can often be executed quickly in a single cpu cycle
capabilities of an agu depend on a particular cpu and its architecture
thus some agus implement and expose more address calculation operations while some also include more advanced specialized instructions that can operate on multiple operands at a time
furthermore some cpu architectures include multiple agus so more than one address calculation operation can be executed simultaneously bringing further performance improvements by capitalizing on the superscalar nature of advanced cpu designs
for example intel incorporates multiple agus into its sandy bridge and haswell microarchitectures which increase bandwidth of the cpu memory subsystem by allowing multiple memory access instructions to be executed in parallel
many microprocessors in smartphones and desktop laptop server computers have a memory management unit translating logical addresses into physical ram addresses providing memory protection and paging abilities useful for virtual memory
simpler processors especially microcontrollers usually don t include an mmu
a cpu cache is a hardware cache used by the central processing unit cpu of a computer to reduce the average cost time or energy to access data from the main memory
a cache is a smaller faster memory closer to a processor core which stores copies of the data from frequently used main memory locations
most cpus have different independent caches including instruction and data caches where the data cache is usually organized as a hierarchy of more cache levels l l l l etc
all modern fast cpus with few specialized exceptions have multiple levels of cpu caches
the first cpus that used a cache had only one level of cache unlike later level caches it was not split into l d for data and l i for instructions
almost all current cpus with caches have a split l cache
they also have l caches and for larger processors l caches as well
the l cache is usually not split and acts as a common repository for the already split l cache
every core of a multi core processor has a dedicated l cache and is usually not shared between the cores
the l cache and higher level caches are shared between the cores and are not split
an l cache is currently uncommon and is generally on dynamic random access memory dram rather than on static random access memory sram on a separate die or chip
that was also the case historically with l while bigger chips have allowed integration of it and generally all cache levels with the possible exception of the last level
each extra level of cache tends to be bigger and be optimized differently
other types of caches exist that are not counted towards the cache size of the most important caches mentioned above such as the translation lookaside buffer tlb that is part of the memory management unit mmu that most cpus have
caches are generally sized in powers of two etc
kib or mib for larger non l sizes although the ibm z has a kib l instruction cache
most cpus are synchronous circuits which means they employ a clock signal to pace their sequential operations
the clock signal is produced by an external oscillator circuit that generates a consistent number of pulses each second in the form of a periodic square wave
the frequency of the clock pulses determines the rate at which a cpu executes instructions and consequently the faster the clock the more instructions the cpu will execute each second
to ensure proper operation of the cpu the clock period is longer than the maximum time needed for all signals to propagate move through the cpu
in setting the clock period to a value well above the worst case propagation delay it is possible to design the entire cpu and the way it moves data around the edges of the rising and falling clock signal
this has the advantage of simplifying the cpu significantly both from a design perspective and a component count perspective
however it also carries the disadvantage that the entire cpu must wait on its slowest elements even though some portions of it are much faster
this limitation has largely been compensated for by various methods of increasing cpu parallelism see below
however architectural improvements alone do not solve all of the drawbacks of globally synchronous cpus
for example a clock signal is subject to the delays of any other electrical signal
higher clock rates in increasingly complex cpus make it more difficult to keep the clock signal in phase synchronized throughout the entire unit
this has led many modern cpus to require multiple identical clock signals to be provided to avoid delaying a single signal significantly enough to cause the cpu to malfunction
another major issue as clock rates increase dramatically is the amount of heat that is dissipated by the cpu
the constantly changing clock causes many components to switch regardless of whether they are being used at that time
in general a component that is switching uses more energy than an element in a static state
therefore as clock rate increases so does energy consumption causing the cpu to require more heat dissipation in the form of cpu cooling solutions
one method of dealing with the switching of unneeded components is called clock gating which involves turning off the clock signal to unneeded components effectively disabling them
however this is often regarded as difficult to implement and therefore does not see common usage outside of very low power designs
one notable recent cpu design that uses extensive clock gating is the ibm powerpc based xenon used in the xbox that way power requirements of the xbox are greatly reduced
another method of addressing some of the problems with a global clock signal is the removal of the clock signal altogether
while removing the global clock signal makes the design process considerably more complex in many ways asynchronous or clockless designs carry marked advantages in power consumption and heat dissipation in comparison with similar synchronous designs
while somewhat uncommon entire asynchronous cpus have been built without using a global clock signal
two notable examples of this are the arm compliant amulet and the mips r compatible minimips
rather than totally removing the clock signal some cpu designs allow certain portions of the device to be asynchronous such as using asynchronous alus in conjunction with superscalar pipelining to achieve some arithmetic performance gains
while it is not altogether clear whether totally asynchronous designs can perform at a comparable or better level than their synchronous counterparts it is evident that they do at least excel in simpler math operations
this combined with their excellent power consumption and heat dissipation properties makes them very suitable for embedded computers
many modern cpus have a die integrated power managing module which regulates on demand voltage supply to the cpu circuitry allowing it to keep balance between performance and power consumption
every cpu represents numerical values in a specific way
for example some early digital computers represented numbers as familiar decimal base numeral system values and others have employed more unusual representations such as ternary base three
nearly all modern cpus represent numbers in binary form with each digit being represented by some two valued physical quantity such as a high or low voltage
related to numeric representation is the size and precision of integer numbers that a cpu can represent
in the case of a binary cpu this is measured by the number of bits significant digits of a binary encoded integer that the cpu can process in one operation which is commonly called word size bit width data path width integer precision or integer size
a cpu s integer size determines the range of integer values it can directly operate on
for example an bit cpu can directly manipulate integers represented by eight bits which have a range of discrete integer values
integer range can also affect the number of memory locations the cpu can directly address an address is an integer value representing a specific memory location
for example if a binary cpu uses bits to represent a memory address then it can directly address memory locations
to circumvent this limitation and for various other reasons some cpus use mechanisms such as bank switching that allow additional memory to be addressed
cpus with larger word sizes require more circuitry and consequently are physically larger cost more and consume more power and therefore generate more heat
as a result smaller or bit microcontrollers are commonly used in modern applications even though cpus with much larger word sizes such as even bit are available
when higher performance is required however the benefits of a larger word size larger data ranges and address spaces may outweigh the disadvantages
a cpu can have internal data paths shorter than the word size to reduce size and cost
for example even though the ibm system instruction set was a bit instruction set the system model and model had bit data paths in the arithmetic logical unit so that a bit add required four cycles one for each bits of the operands and even though the motorola series instruction set was a bit instruction set the motorola and motorola had bit data paths in the arithmetic logical unit so that a bit add required two cycles
to gain some of the advantages afforded by both lower and higher bit lengths many instruction sets have different bit widths for integer and floating point data allowing cpus implementing that instruction set to have different bit widths for different portions of the device
for example the ibm system instruction set was primarily bit but supported bit floating point values to facilitate greater accuracy and range in floating point numbers
the system model had an bit adder for decimal and fixed point binary arithmetic and a bit adder for floating point arithmetic
many later cpu designs use similar mixed bit width especially when the processor is meant for general purpose usage where a reasonable balance of integer and floating point capability is required
the description of the basic operation of a cpu offered in the previous section describes the simplest form that a cpu can take
this type of cpu usually referred to as subscalar operates on and executes one instruction on one or two pieces of data at a time that is less than one instruction per clock cycle ipc
this process gives rise to an inherent inefficiency in subscalar cpus
since only one instruction is executed at a time the entire cpu must wait for that instruction to complete before proceeding to the next instruction
as a result the subscalar cpu gets hung up on instructions which take more than one clock cycle to complete execution
even adding a second execution unit see below does not improve performance much rather than one pathway being hung up now two pathways are hung up and the number of unused transistors is increased
this design wherein the cpu s execution resources can operate on only one instruction at a time can only possibly reach scalar performance one instruction per clock cycle ipc
however the performance is nearly always subscalar less than one instruction per clock cycle ipc
attempts to achieve scalar and better performance have resulted in a variety of design methodologies that cause the cpu to behave less linearly and more in parallel
when referring to parallelism in cpus two terms are generally used to classify these design techniques
instruction level parallelism ilp which seeks to increase the rate at which instructions are executed within a cpu that is to increase the use of on die execution resources
task level parallelism tlp which purposes to increase the number of threads or processes that a cpu can execute simultaneously each methodology differs both in the ways in which they are implemented as well as the relative effectiveness they afford in increasing the cpu s performance for an application
one of the simplest methods for increased parallelism is to begin the first steps of instruction fetching and decoding before the prior instruction finishes executing
this is a technique known as instruction pipelining and is used in almost all modern general purpose cpus
pipelining allows multiple instruction to be executed at a time by breaking the execution pathway into discrete stages
this separation can be compared to an assembly line in which an instruction is made more complete at each stage until it exits the execution pipeline and is retired
pipelining does however introduce the possibility for a situation where the result of the previous operation is needed to complete the next operation a condition often termed data dependency conflict
therefore pipelined processors must check for these sorts of conditions and delay a portion of the pipeline if necessary
a pipelined processor can become very nearly scalar inhibited only by pipeline stalls an instruction spending more than one clock cycle in a stage
improvements in instruction pipelining led to further decreases in the idle time of cpu components
designs that are said to be superscalar include a long instruction pipeline and multiple identical execution units such as load store units arithmetic logic units floating point units and address generation units
in a superscalar pipeline instructions are read and passed to a dispatcher which decides whether or not the instructions can be executed in parallel simultaneously
if so they are dispatched to execution units resulting in their simultaneous execution
in general the number of instructions that a superscalar cpu will complete in a cycle is dependent on the number of instructions it is able to dispatch simultaneously to execution units
most of the difficulty in the design of a superscalar cpu architecture lies in creating an effective dispatcher
the dispatcher needs to be able to quickly determine whether instructions can be executed in parallel as well as dispatch them in such a way as to keep as many execution units busy as possible
this requires that the instruction pipeline is filled as often as possible and requires significant amounts of cpu cache
it also makes hazard avoiding techniques like branch prediction speculative execution register renaming out of order execution and transactional memory crucial to maintaining high levels of performance
by attempting to predict which branch or path a conditional instruction will take the cpu can minimize the number of times that the entire pipeline must wait until a conditional instruction is completed
speculative execution often provides modest performance increases by executing portions of code that may not be needed after a conditional operation completes
out of order execution somewhat rearranges the order in which instructions are executed to reduce delays due to data dependencies
also in case of single instruction stream multiple data stream a case when a lot of data from the same type has to be processed modern processors can disable parts of the pipeline so that when a single instruction is executed many times the cpu skips the fetch and decode phases and thus greatly increases performance on certain occasions especially in highly monotonous program engines such as video creation software and photo processing
in the case where just a portion of the cpu is superscalar the part which is not suffers a performance penalty due to scheduling stalls
the intel p pentium had two superscalar alus which could accept one instruction per clock cycle each but its fpu could not
thus the p was integer superscalar but not floating point superscalar
intel s successor to the p architecture p added superscalar abilities to its floating point features
simple pipelining and superscalar design increase a cpu s ilp by allowing it to execute instructions at rates surpassing one instruction per clock cycle
most modern cpu designs are at least somewhat superscalar and nearly all general purpose cpus designed in the last decade are superscalar
in later years some of the emphasis in designing high ilp computers has been moved out of the cpu s hardware and into its software interface or instruction set architecture isa
the strategy of the very long instruction word vliw causes some ilp to become implied directly by the software reducing the cpu s work in boosting ilp and thereby reducing design complexity
another strategy of achieving performance is to execute multiple threads or processes in parallel
this area of research is known as parallel computing
in flynn s taxonomy this strategy is known as multiple instruction stream multiple data stream mimd
one technology used for this purpose was multiprocessing mp
the initial flavor of this technology is known as symmetric multiprocessing smp where a small number of cpus share a coherent view of their memory system
in this scheme each cpu has additional hardware to maintain a constantly up to date view of memory
by avoiding stale views of memory the cpus can cooperate on the same program and programs can migrate from one cpu to another
to increase the number of cooperating cpus beyond a handful schemes such as non uniform memory access numa and directory based coherence protocols were introduced in the s
smp systems are limited to a small number of cpus while numa systems have been built with thousands of processors
initially multiprocessing was built using multiple discrete cpus and boards to implement the interconnect between the processors
when the processors and their interconnect are all implemented on a single chip the technology is known as chip level multiprocessing cmp and the single chip as a multi core processor
it was later recognized that finer grain parallelism existed with a single program
a single program might have several threads or functions that could be executed separately or in parallel
some of the earliest examples of this technology implemented input output processing such as direct memory access as a separate thread from the computation thread
a more general approach to this technology was introduced in the s when systems were designed to run multiple computation threads in parallel
this technology is known as multi threading mt
this approach is considered more cost effective than multiprocessing as only a small number of components within a cpu is replicated to support mt as opposed to the entire cpu in the case of mp
in mt the execution units and the memory system including the caches are shared among multiple threads
the downside of mt is that the hardware support for multithreading is more visible to software than that of mp and thus supervisor software like operating systems have to undergo larger changes to support mt
one type of mt that was implemented is known as temporal multithreading where one thread is executed until it is stalled waiting for data to return from external memory
in this scheme the cpu would then quickly context switch to another thread which is ready to run the switch often done in one cpu clock cycle such as the ultrasparc t
another type of mt is simultaneous multithreading where instructions from multiple threads are executed in parallel within one cpu clock cycle
for several decades from the s to early s the focus in designing high performance general purpose cpus was largely on achieving high ilp through technologies such as pipelining caches superscalar execution out of order execution etc
this trend culminated in large power hungry cpus such as the intel pentium
by the early s cpu designers were thwarted from achieving higher performance from ilp techniques due to the growing disparity between cpu operating frequencies and main memory operating frequencies as well as escalating cpu power dissipation owing to more esoteric ilp techniques
cpu designers then borrowed ideas from commercial computing markets such as transaction processing where the aggregate performance of multiple programs also known as throughput computing was more important than the performance of a single thread or process
this reversal of emphasis is evidenced by the proliferation of dual and more core processor designs and notably intel s newer designs resembling its less superscalar p architecture
late designs in several processor families exhibit cmp including the x opteron and athlon x the sparc ultrasparc t ibm power and power as well as several video game console cpus like the xbox s triple core powerpc design and the playstation s core cell microprocessor
a less common but increasingly important paradigm of processors and indeed computing in general deals with data parallelism
the processors discussed earlier are all referred to as some type of scalar device
as the name implies vector processors deal with multiple pieces of data in the context of one instruction
this contrasts with scalar processors which deal with one piece of data for every instruction
using flynn s taxonomy these two schemes of dealing with data are generally referred to as single instruction stream multiple data stream simd and single instruction stream single data stream sisd respectively
the great utility in creating processors that deal with vectors of data lies in optimizing tasks that tend to require the same operation for example a sum or a dot product to be performed on a large set of data
some classic examples of these types of tasks include multimedia applications images video and sound as well as many types of scientific and engineering tasks
whereas a scalar processor must complete the entire process of fetching decoding and executing each instruction and value in a set of data a vector processor can perform a single operation on a comparatively large set of data with one instruction
this is only possible when the application tends to require many steps which apply one operation to a large set of data
most early vector processors such as the cray were associated almost exclusively with scientific research and cryptography applications
however as multimedia has largely shifted to digital media the need for some form of simd in general purpose processors has become significant
shortly after inclusion of floating point units started to become commonplace in general purpose processors specifications for and implementations of simd execution units also began to appear for general purpose processors
some of these early simd specifications like hp s multimedia acceleration extensions max and intel s mmx were integer only
this proved to be a significant impediment for some software developers since many of the applications that benefit from simd primarily deal with floating point numbers
progressively developers refined and remade these early designs into some of the common modern simd specifications which are usually associated with one instruction set architecture isa
some notable modern examples include intel s streaming simd extensions sse and the powerpc related altivec also known as vmx
many modern architectures including embedded ones often include hardware performance counters hpc which enables low level instruction level collection benchmarking debugging or analysis of running software metrics
hpc may also be used to discover and analyze unusual or suspicious activity of the software such as return oriented programming rop or sigreturn oriented programming srop exploits etc
this is usually done by software security teams to assess and find malicious binary programs
many major vendors such as ibm intel amd and arm etc provide software interfaces usually written in c c that can be used to collected data from cpus registers in order to get metrics
operating system vendors also provide software like perf linux to record benchmark or trace cpu events running kernels and applications
cloud computing can involve subdividing cpu operation into virtual central processing units vcpus
a host is the virtual equivalent of a physical machine on which a virtual system is operating
when there are several physical machines operating in tandem and managed as a whole the grouped computing and memory resources form a cluster
in some systems it is possible to dynamically add and remove from a cluster
resources available at a host and cluster level can be partitioned out into resources pools with fine granularity
the performance or speed of a processor depends on among many other factors the clock rate generally given in multiples of hertz and the instructions per clock ipc which together are the factors for the instructions per second ips that the cpu can perform
many reported ips values have represented peak execution rates on artificial instruction sequences with few branches whereas realistic workloads consist of a mix of instructions and applications some of which take longer to execute than others
the performance of the memory hierarchy also greatly affects processor performance an issue barely considered in mips calculations
because of these problems various standardized tests often called benchmarks for this purpose such as specint have been developed to attempt to measure the real effective performance in commonly used applications
processing performance of computers is increased by using multi core processors which essentially is plugging two or more individual processors called cores in this sense into one integrated circuit
ideally a dual core processor would be nearly twice as powerful as a single core processor
in practice the performance gain is far smaller only about due to imperfect software algorithms and implementation
increasing the number of cores in a processor i e
dual core quad core etc increases the workload that can be handled
this means that the processor can now handle numerous asynchronous events interrupts etc
which can take a toll on the cpu when overwhelmed
these cores can be thought of as different floors in a processing plant with each floor handling a different task
sometimes these cores will handle the same tasks as cores adjacent to them if a single core is not enough to handle the information
due to specific capabilities of modern cpus such as simultaneous multithreading and uncore which involve sharing of actual cpu resources while aiming at increased utilization monitoring performance levels and hardware use gradually became a more complex task
as a response some cpus implement additional hardware logic that monitors actual use of various parts of a cpu and provides various counters accessible to software an example is intel s performance counter monitor technology
how microprocessors work at howstuffworks
microchips that shook the world an article by the institute of electrical and electronics engineers

